<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Å—Ç–æ–π Ping/Pong + Offer/Answer —Ç–µ—Å—Ç</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .user-section { border: 2px solid #ccc; padding: 20px; margin: 10px 0; border-radius: 10px; }
        .user1 { border-color: #2196F3; background: #f0f8ff; }
        .user2 { border-color: #4CAF50; background: #f0fff0; }
        .log { background: #000; color: #0f0; padding: 10px; height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; }
        .ping-btn { background: #FF9800; color: white; }
        .signaling-btn { background: #2196F3; color: white; }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #FF9800; }
        .info { color: #2196F3; }
        video { width: 200px; height: 150px; border: 1px solid #ccc; margin: 10px; }
    </style>
</head>
<body>
    <h1>üîó –ü—Ä–æ—Å—Ç–æ–π Ping/Pong + Offer/Answer —Ç–µ—Å—Ç</h1>
    <p>–¢–µ—Å—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ ping/pong –∏ –æ–±–º–µ–Ω offer/answer –±–µ–∑ WebRTC</p>

    <div class="user-section user1">
        <h2>üë§ User 1</h2>
        <div>
            <button onclick="pingUser1()" class="ping-btn" id="pingBtn1">üì° Ping User 2</button>
            <button onclick="testOffer1()" class="signaling-btn" id="offerBtn1" disabled>üì§ –¢–µ—Å—Ç Offer</button>
        </div>
        <div>
            <video id="localVideo1" autoplay muted></video>
            <video id="remoteVideo1" autoplay></video>
        </div>
        <div class="log" id="log1"></div>
    </div>

    <div class="user-section user2">
        <h2>üë§ User 2</h2>
        <div>
            <button onclick="pingUser2()" class="ping-btn" id="pingBtn2">üì° Ping User 1</button>
            <button onclick="testAnswer2()" class="signaling-btn" id="answerBtn2" disabled>üì• –¢–µ—Å—Ç Answer</button>
        </div>
        <div>
            <video id="localVideo2" autoplay muted></video>
            <video id="remoteVideo2" autoplay></video>
        </div>
        <div class="log" id="log2"></div>
    </div>

    <script>
        const SIGNALING_SERVER = 'https://lizamsg.ru:3000/api/signaling';
        
        // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        const user1 = {
            id: 'user1',
            state: 'idle',
            targetUser: null,
            lastSignalTime: Date.now(),
            log: (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('log1');
                const colorClass = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info';
                logElement.innerHTML += `<div class="${colorClass}">[${timestamp}] ${message}</div>`;
                logElement.scrollTop = logElement.scrollHeight;
            }
        };

        const user2 = {
            id: 'user2',
            state: 'idle',
            targetUser: null,
            lastSignalTime: Date.now(),
            log: (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('log2');
                const colorClass = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info';
                logElement.innerHTML += `<div class="${colorClass}">[${timestamp}] ${message}</div>`;
                logElement.scrollTop = logElement.scrollHeight;
            }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        async function init() {
            user1.log('üöÄ –ó–∞–ø—É—Å–∫ User 1', 'info');
            user2.log('üöÄ –ó–∞–ø—É—Å–∫ User 2', 'info');
            
            // –ü–æ–ª—É—á–∞–µ–º –º–µ–¥–∏–∞ –ø–æ—Ç–æ–∫–∏
            try {
                user1.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                user2.localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                
                document.getElementById('localVideo1').srcObject = user1.localStream;
                document.getElementById('localVideo2').srcObject = user2.localStream;
                
                user1.log('‚úÖ –ú–µ–¥–∏–∞ –ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω', 'success');
                user2.log('‚úÖ –ú–µ–¥–∏–∞ –ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω', 'success');
            } catch (error) {
                user1.log(`‚ùå –û—à–∏–±–∫–∞ –º–µ–¥–∏–∞: ${error.message}`, 'error');
                user2.log(`‚ùå –û—à–∏–±–∫–∞ –º–µ–¥–∏–∞: ${error.message}`, 'error');
            }

            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É —Å–∏–≥–Ω–∞–ª–æ–≤
            setInterval(() => checkSignals(user1), 2000);
            setInterval(() => checkSignals(user2), 2000);
        }

        // Ping —Ñ—É–Ω–∫—Ü–∏–∏
        async function pingUser1() {
            await sendPing(user1, user2);
        }

        async function pingUser2() {
            await sendPing(user2, user1);
        }

        // –û—Ç–ø—Ä–∞–≤–∫–∞ ping
        async function sendPing(caller, target) {
            if (caller.state !== 'idle') {
                caller.log('‚ö†Ô∏è –£–∂–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'warning');
                return;
            }

            try {
                caller.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ ping –∫ ${target.id}`, 'warning');
                caller.state = 'connecting';
                caller.targetUser = target.id;
                
                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'signal',
                        from: caller.id,
                        to: target.id,
                        type: 'ping',
                        data: { test: true }
                    })
                });

                const result = await response.json();
                caller.log(`üì° –û—Ç–≤–µ—Ç: ${JSON.stringify(result)}`, 'info');
                
                if (result.success) {
                    caller.log(`‚úÖ ping –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                } else {
                    caller.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ${result.error}`, 'error');
                    caller.state = 'idle';
                    caller.targetUser = null;
                }
            } catch (error) {
                caller.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
                caller.state = 'idle';
                caller.targetUser = null;
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤
        async function checkSignals(user) {
            try {
                const response = await fetch(`${SIGNALING_SERVER}?action=signals&userId=${user.id}&since=${user.lastSignalTime}`);
                const result = await response.json();
                
                if (result.success && result.signals.length > 0) {
                    user.log(`üì® –ü–æ–ª—É—á–µ–Ω–æ ${result.signals.length} —Å–∏–≥–Ω–∞–ª–æ–≤`, 'info');
                    
                    result.signals.forEach(signal => {
                        user.lastSignalTime = signal.timestamp;
                        handleSignal(user, signal);
                    });
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤: ${error.message}`, 'error');
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤
        function handleSignal(user, signal) {
            user.log(`üì® ${signal.type} –æ—Ç ${signal.from}`, 'info');

            if (signal.type === 'ping') {
                handlePing(user, signal);
            } else if (signal.type === 'pong') {
                handlePong(user, signal);
            } else if (signal.type === 'offer') {
                handleOffer(user, signal);
            } else if (signal.type === 'answer') {
                handleAnswer(user, signal);
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ ping
        async function handlePing(user, signal) {
            if (user.state !== 'idle') {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º ping - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
                return;
            }

            try {
                user.log(`üèì –ü–æ–ª—É—á–µ–Ω ping –æ—Ç ${signal.from} - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º pong`, 'warning');
                user.state = 'connecting';
                user.targetUser = signal.from;

                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'signal',
                        from: user.id,
                        to: signal.from,
                        type: 'pong',
                        data: { received: true }
                    })
                });

                const result = await response.json();
                if (result.success) {
                    user.log(`‚úÖ pong –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                    user.state = 'connected';
                    user.log(`üîó P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ!`, 'success');
                    updateButtons(user);
                } else {
                    user.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ pong: ${result.error}`, 'error');
                    user.state = 'idle';
                    user.targetUser = null;
                }
            } catch (error) {
                user.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
                user.state = 'idle';
                user.targetUser = null;
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ pong
        function handlePong(user, signal) {
            if (user.state === 'connecting' && user.targetUser === signal.from) {
                user.log(`üèì –ü–æ–ª—É—á–µ–Ω pong –æ—Ç ${signal.from} - —Å–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!`, 'success');
                user.state = 'connected';
                user.log(`üîó P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ!`, 'success');
                updateButtons(user);
            } else {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º pong –æ—Ç ${signal.from} - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ offer
        function handleOffer(user, signal) {
            if (user.state !== 'connected') {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º offer - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
                return;
            }

            user.log(`üì• –ü–æ–ª—É—á–µ–Ω offer –æ—Ç ${signal.from}`, 'warning');
            user.log(`üì• Offer –¥–∞–Ω–Ω—ã–µ: type=${signal.data.type}, sdp –¥–ª–∏–Ω–∞=${signal.data.sdp ? signal.data.sdp.length : 'undefined'}`, 'info');
            user.log(`üì• –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${user.state}`, 'info');
            
            // –í–∫–ª—é—á–∞–µ–º –∫–Ω–æ–ø–∫—É answer –¥–ª—è User 2
            if (user.id === 'user2') {
                document.getElementById('answerBtn2').disabled = false;
                user.log(`üí° –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –Ω–∞–∂–∞—Ç—å "–¢–µ—Å—Ç Answer"`, 'info');
            }
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ answer
        function handleAnswer(user, signal) {
            if (user.state !== 'connected') {
                user.log(`‚ö†Ô∏è –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º answer - —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${user.state}`, 'warning');
                return;
            }

            user.log(`üì• –ü–æ–ª—É—á–µ–Ω answer –æ—Ç ${signal.from}`, 'warning');
            user.log(`üì• Answer –¥–∞–Ω–Ω—ã–µ: type=${signal.data.type}, sdp –¥–ª–∏–Ω–∞=${signal.data.sdp ? signal.data.sdp.length : 'undefined'}`, 'info');
            user.log(`‚úÖ Offer/Answer –æ–±–º–µ–Ω –∑–∞–≤–µ—Ä—à–µ–Ω!`, 'success');
        }

        // –¢–µ—Å—Ç offer
        async function testOffer1() {
            if (user1.state !== 'connected') {
                user1.log('‚ö†Ô∏è –ù–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ offer', 'warning');
                return;
            }

            try {
                user1.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ offer –∫ user2`, 'warning');
                
                const testOffer = {
                    type: 'offer',
                    sdp: 'v=0\r\no=- 1234567890 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\na=group:BUNDLE 0\r\nm=audio 9 UDP/TLS/RTP/SAVPF 111\r\nc=IN IP4 0.0.0.0\r\na=rtcp:9 IN IP4 0.0.0.0\r\na=ice-ufrag:test\r\na=ice-pwd:test\r\na=fingerprint:sha-256 test\r\na=setup:actpass\r\na=mid:0\r\na=sendrecv\r\na=rtpmap:111 opus/48000/2\r\n'
                };

                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'signal',
                        from: user1.id,
                        to: 'user2',
                        type: 'offer',
                        data: testOffer
                    })
                });

                const result = await response.json();
                if (result.success) {
                    user1.log(`‚úÖ –¢–µ—Å—Ç–æ–≤—ã–π offer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                } else {
                    user1.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ offer: ${result.error}`, 'error');
                }
            } catch (error) {
                user1.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
            }
        }

        // –¢–µ—Å—Ç answer
        async function testAnswer2() {
            if (user2.state !== 'connected') {
                user2.log('‚ö†Ô∏è –ù–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ answer', 'warning');
                return;
            }

            try {
                user2.log(`üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ answer –∫ user1`, 'warning');
                
                const testAnswer = {
                    type: 'answer',
                    sdp: 'v=0\r\no=- 1234567890 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\na=group:BUNDLE 0\r\nm=audio 9 UDP/TLS/RTP/SAVPF 111\r\nc=IN IP4 0.0.0.0\r\na=rtcp:9 IN IP4 0.0.0.0\r\na=ice-ufrag:test\r\na=ice-pwd:test\r\na=fingerprint:sha-256 test\r\na=setup:active\r\na=mid:0\r\na=sendrecv\r\na=rtpmap:111 opus/48000/2\r\n'
                };

                const response = await fetch(SIGNALING_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'signal',
                        from: user2.id,
                        to: 'user1',
                        type: 'answer',
                        data: testAnswer
                    })
                });

                const result = await response.json();
                if (result.success) {
                    user2.log(`‚úÖ –¢–µ—Å—Ç–æ–≤—ã–π answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ`, 'success');
                } else {
                    user2.log(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ answer: ${result.error}`, 'error');
                }
            } catch (error) {
                user2.log(`‚ùå –û—à–∏–±–∫–∞: ${error.message}`, 'error');
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–æ–∫
        function updateButtons(user) {
            if (user.id === 'user1') {
                document.getElementById('pingBtn1').disabled = true;
                document.getElementById('offerBtn1').disabled = false;
            } else {
                document.getElementById('pingBtn2').disabled = true;
                // answerBtn2 –≤–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ offer
            }
        }

        // –ó–∞–ø—É—Å–∫
        init();
    </script>
</body>
</html>
